//---------------------------------------------------------------------------
/*
	Risa [りさ]      alias 吉里吉里3 [kirikiri-3]
	 stands for "Risa Is a Stagecraft Architecture"
	Copyright (C) 2000-2006 W.Dee <dee@kikyou.info> and contributors

	See details of license at "license.txt"
*/
//---------------------------------------------------------------------------
//! @file
//! @brief マルチスレッド関連ユーティリティ
//---------------------------------------------------------------------------
#include "prec.h"
#include "base/utils/RisaThread.h"

RISSE_DEFINE_SOURCE_ID(24795,6838,687,16805,21894,40786,6545,48673);

/*! @note

Risa は wxWidgets と boost という２つのライブラリのスレッド実装の恩恵を
受けられる状態にあるが、それぞれは微妙に Risa の要求からはずれている。

ここでは、スレッド関連の実装の比較を行う。

以下の「問題あり」「問題なし」は、Risa の用途で問題があるか無いかということ
であり、それぞれの実装が単純に「ダメか」「良いか」ということを言っているの
ではない。

■ スレッドの実装

	- wxThread						問題あり
	- boost::thread					問題あり

	wxThread は設計上の問題があり、Risaの用途では使うことができない
	( Wait()やDelete()でメッセージループを動かしてしまう)

	boost::thread はスレッドの優先順位を指定できない。

	ここでは、wxThread の Wait() や Delete() でメッセージループを動かして
	しまうといった問題に対し、wxThread をベースに Wait の動作を独自に実装
	することで解決を図る。


■ CriticalSection の実装

	- wxCriticalSection				問題あり
	- boost::recursive_mutex		とくに問題なし
	- tRisseCiriticalSection		問題なし

	wxCriticalSection は、再帰的な(再入可能な)クリティカルセクションを実現できる
	保証がない。boost::recursive_mutex はその名の通り再入可能な mutex だが、
	たとえば Windows の提供する CriticalSection よりは効率が悪い。
	tRisseCiriticalSection は、プラットフォームネイティブなクリティカルセクショ
	ンを利用できる場合は利用するようになっているのでもっとも効率がよい。

	ここでは、tRisseCriticalSection を typedef したものを tRisaCriticalSection
	として用いて使うこととする。
*/


//---------------------------------------------------------------------------
//! @brief		コンストラクタ
//---------------------------------------------------------------------------
tRisaThread::tRisaThread() : wxThread(wxTHREAD_JOINABLE)
{
	_Terminated = false;
	// スレッドを作成する
	Create();
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//! @brief		デストラクタ
//---------------------------------------------------------------------------
tRisaThread::~tRisaThread()
{
	Wait();
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//! @brief		スレッドの実行を開始する
//---------------------------------------------------------------------------
void tRisaThread::Run()
{
	wxThread::Run();
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//! @brief		スレッドが終了するまで待つ
//---------------------------------------------------------------------------
void tRisaThread::Wait()
{
	Terminate();
	wxMutexLocker lock(ThreadMutex); // スレッドが終了するまで待つ
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//! @brief		スレッドのメイン関数(wxThread::Entryのオーバーライド)
//---------------------------------------------------------------------------
wxThread::ExitCode tRisaThread::Entry()
{
	try
	{
		volatile wxMutexLocker lock(ThreadMutex); // スレッドが終了するまで待つ

		Execute(); // スレッドのメイン関数を実行する
	}
	catch(...)
	{
		// ??? なにかここでやるべき？
	}

	Exit(0); // この関数はもどらない

	return 0;
}
//---------------------------------------------------------------------------

